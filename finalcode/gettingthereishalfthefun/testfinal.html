<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>OSM Space-Time Cube</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }

    #canvas {
      width: 100%;
      height: 100%;
    }
  </style>
</head>

<body>
  <div id="canvas"></div>

  <script src="https://d3js.org/d3.v6.min.js"></script>
  <script type="module">
    import * as THREE from 'https://cdn.skypack.dev/three@0.132.2/build/three.module.js';
    import {
      OrbitControls
    } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/controls/OrbitControls.js';

    const c = 200;
    const minDate = new Date("2019-04-28T16:47:13Z");
    const maxDate = new Date("2019-04-28T17:03:32Z");

    const timeScale = d3.scaleTime().domain([minDate, maxDate]).range([0, c]);

    function project3D(coord, t = minDate) {
      const lon = coord[0];
      const lat = coord[1];
      const time = timeScale(t);

      const x = ((lon - 77.5945627) / 0.007441) * (c / 2);
      const y = time;
      const z = ((lat - 12.9715987) / 0.007441) * (c / 2);

      return new THREE.Vector3(x, y, z);
    }

    function getTilesForLocation(lat, lon, zoom) {
      const top_tile = ytile(lat, zoom);
      const left_tile = xtile(lon, zoom);
      const bottom_tile = top_tile;
      const right_tile = left_tile;

      return {
        zoom,
        top_tile,
        left_tile,
        bottom_tile,
        right_tile
      };
    }

    function xtile(lon, zoom) {
      return Math.floor(((lon + 180) / 360) * Math.pow(2, zoom));
    }

    function ytile(lat, zoom) {
      return Math.floor(
        ((1 -
          Math.log(
            Math.tan((lat * Math.PI) / 180) + 1 / Math.cos((lat * Math.PI) / 180)
          ) /
          Math.PI) /
          2) *
        Math.pow(2, zoom)
      );
    }

    function getTileURL(tiles) {
      const { zoom, left_tile, top_tile } = tiles;
      const tileURL = `https://api.mapbox.com/styles/v1/mapbox/streets-v11/tiles/256/${zoom}/${left_tile}/${top_tile}@2x?access_token=pk.eyJ1IjoicG9vcm5pLWJhZHJpbmF0aCIsImEiOiJjanUwbmYzc3UwdDI3NGRtZ3kzMTltbWZpIn0.SB9PEksVcEwWvZJ9A7J9uA`;
      return tileURL;
    }

    function getTileBounds(tiles) {
      var n = Math.pow(2, tiles.zoom);
      // Top left
      var lon_deg = (tiles.left_tile / n) * 360 - 180;
      var lat_rad = Math.atan(Math.sinh(Math.PI * (1 - (2 * tiles.top_tile) / n)));
      var lat_deg = (lat_rad * 180.0) / Math.PI;
      // Bottom right
      var lon_deg2 = ((tiles.left_tile + 1) / n) * 360 - 180;
      var lat_rad2 = Math.atan(Math.sinh(Math.PI * (1 - (2 * (tiles.top_tile + 1)) / n)));
      var lat_deg2 = (lat_rad2 * 180.0) / Math.PI;

      return { top: lat_deg, left: lon_deg, right: lon_deg2, bottom: lat_deg2 };
    }

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById("canvas").appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.update();

    camera.position.z = 300;
    camera.position.y = 150;

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Light
    const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
    directionalLight.position.set(1, 1, 0);
    scene.add(directionalLight);

    // Base Map
    var tiles = getTilesForLocation(12.9994, 77.5931, 10);
    var tileBounds = getTileBounds(tiles);
    var tileURL = getTileURL(tiles);

    var texture = new THREE.TextureLoader().load(tileURL);
    var material = new THREE.MeshBasicMaterial({ map: texture });
    var geometry = new THREE.PlaneGeometry(c, c);
    var mesh = new THREE.Mesh(geometry, material);
    mesh.position.x = 0;
    mesh.position.y = -c / 2;
    mesh.position.z = 0;
    mesh.rotation.x = -Math.PI / 2;
    mesh.rotation.z = Math.PI / 2;
    scene.add(mesh);

    const loader = new THREE.FileLoader();
    loader.load('https://raw.githubusercontent.com/poornibadrinath/gettingthereishalfthefun/main/routeone.geojson?token=GHSAT0AAAAAACEG46TKK56LNJ76BLYSZDXSZETSJCA', function (geojson) {
      const data = JSON.parse(geojson);
      var lineString = data.features[0].geometry.coordinates;

      // Convert GeoJSON coordinates to projected 3D coordinates
      var coord = lineString.map(d => project3D(d)).filter(isWithinCube);

      // Create a 3D curve from the projected coordinates
      var curve = new THREE.CatmullRomCurve3(coord);
      var curvePoints = curve.getPoints(coord.length * 10);
      var curveGeometry = new THREE.BufferGeometry().setFromPoints(curvePoints);
      var curveMaterial = new THREE.LineBasicMaterial({
        color: "#777"
      });
      var curveObject = new THREE.Line(curveGeometry, curveMaterial);
      scene.add(curveObject);
    });

    function isWithinCube(coord) {
      const x = coord.x;
      const y = coord.y;
      const z = coord.z;

      if (Math.abs(x) <= c / 2 && Math.abs(y) <= c && Math.abs(z) <= c / 2) {
        return true;
      } else {
        return false;
      }
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>

</html>
