<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>OSM Space-Time Cube</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }

    #canvas {
      width: 100%;
      height: 100%;
    }

    .popup {
      position: absolute;
      background: white;
      padding: 10px;
      border-radius: 5px;
      pointer-events: none;
    }
  </style>
</head>

<body>
  <div id="canvas"></div>
  <div id="popup" class="popup"></div>

  <script src="https://d3js.org/d3.v6.min.js"></script>
  <script type="module">
    import * as THREE from 'https://cdn.skypack.dev/three@0.132.2/build/three.module.js';
    import {
      OrbitControls
    } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/controls/OrbitControls.js';

    const c = 200;
    const minDate = new Date("2019-04-22T16:47:13Z");
    const maxDate = new Date("2019-04-22T17:30:00Z");

    const timeScale = d3.scaleTime().domain([minDate, maxDate]).range([0, c]);

    function project3D(coord, t = minDate) {
      const lon = coord[0];
      const lat = coord[1];
      const time = timeScale(t);

      const x = ((lon - 4.895168) / 0.007441) * (c / 2);
      const y = time - c / 2;
      const z = ((lat - 52.370216) / 0.007441) * (c / 2);

      return new THREE.Vector3(x, y, z);
    }

    const scene = new THREE.Scene();
    scene.background = new THREE.Color("#fff");

    const box = new THREE.BoxGeometry(c, c, c);
    const geo = new THREE.EdgesGeometry(box);
    const mat = new THREE.LineBasicMaterial({
      color: 0xdddddd,
      linewidth: 30
    });
    const wireframe = new THREE.LineSegments(geo, mat);
    scene.add(wireframe);

    const tiles = getTilesForLocation(52.37403, 4.88969, 10);
    const tileURL = getTileURL(tiles);

    const texture = new THREE.TextureLoader().load(tileURL);
    const material = new THREE.MeshBasicMaterial({
      map: texture
    });
    const geometry = new THREE.PlaneGeometry(c, c);
    const mesh = new THREE.Mesh(geometry, material);
    mesh.position.x = 0;
    mesh.position.y = -c / 2;
    mesh.position.z = 0;
    mesh.rotation.x = -Math.PI / 2;
    mesh.rotation.z = Math.PI / 2;
    scene.add(mesh);

    const data = [{
        lon: 4.895168,
        lat: 52.370216,
        time: new Date("2019-04-22T16:47:13Z"),
        congestion: 0.8, // Traffic congestion value (between 0 and 1)
        timeTaken: 0.1 // Time taken for this point
      },
      {
        lon: 4.890168,
        lat: 52.372216,
        time: new Date("2019-04-22T17:00:00Z"),
        congestion: 0.6,
        timeTaken: 0.6
      },
      {
        lon: 4.895568,
        lat: 52.370216,
        time: new Date("2019-04-22T17:15:00Z"),
        congestion: 0.4,
        timeTaken: 0.4
      },
      {
        lon: 4.890568,
        lat: 52.372216,
        time: new Date("2019-04-22T17:30:00Z"),
        congestion: 1.0,
        timeTaken: 1.0
      }
      // Add more data points as needed
    ];

    const congestionColorScale = d3.scaleLinear()
      .domain([0, 1])
      .range(["green", "red"]);

    const curve = new THREE.CatmullRomCurve3(data.map(d => project3D([d.lon, d.lat], d.time)));
    const tubeGeometry = new THREE.TubeGeometry(curve, 100, 1, 8, false);
    const colors = [];
    for (let i = 0; i < tubeGeometry.attributes.position.count; i++) {
      const congestion = data[Math.floor(i / (tubeGeometry.attributes.position.count / data.length))].congestion;
      const color = new THREE.Color(congestionColorScale(congestion));
      colors.push(color.r, color.g, color.b);
    }
    tubeGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
    const material2 = new THREE.MeshBasicMaterial({
      vertexColors: THREE.VertexColors
    });
    const line = new THREE.Mesh(tubeGeometry, material2);
    scene.add(line);

    const renderer = new THREE.WebGLRenderer({
      antialias: true
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('canvas').appendChild(renderer.domElement);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.x = 0;
    camera.position.y = c / 2;
    camera.position.z = c;
    camera.lookAt(scene.position);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.update();

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    animate();

    const popup = document.getElementById('popup');

    function onMouseMove(event) {
      const mouse = new THREE.Vector2();
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

      const raycaster = new THREE.Raycaster();
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObject(line);

      if (intersects.length > 0) {
        const point = intersects[0].point;
        const [lon, lat] = reverseProject3D(point);

        const time = timeScale.invert(point.y + c / 2);
        const formattedTime = time.toLocaleTimeString('en-US', {
          hour: 'numeric',
          minute: 'numeric',
          second: 'numeric'
        });

        popup.style.left = `${event.clientX + 10}px`;
        popup.style.top = `${event.clientY + 10}px`;
        popup.textContent = `Latitude: ${lat.toFixed(6)}, Longitude: ${lon.toFixed(6)}, Time: ${formattedTime}`;
      } else {
        popup.textContent = '';
      }
    }

    window.addEventListener('mousemove', onMouseMove, false);

    function getTilesForLocation(lat, lon, zoom) {
      const tiles = [];
      const lat_rad = lat * Math.PI / 180;
      const n = 2.0 ** zoom;
      const x = Math.floor(n * ((lon + 180) / 360));
      const y = Math.floor((1.0 - Math.asinh(Math.tan(lat_rad)) / Math.PI) / 2.0 * n);
      tiles.push({
        x: x,
        y: y,
        z: zoom
      });
      return tiles;
    }

    function getTileURL(tiles) {
      const tile = tiles[0];
      const {
        x,
        y,
        z
      } = tile;x
      return `https://a.tile.openstreetmap.org/${z}/${x}/${y}.png`;
    }

    function reverseProject3D(point) {
      const lon = (point.x / (c / 2) * 0.007441) + 4.895168;
      const lat = (point.z / (c / 2) * 0.007441) + 52.372216;

      return [lon, lat];
    }
  </script>
</body>

</html>


