<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Space-Time Cube Example</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
  <script src="https://threejs.org/build/three.js"></script>
  <script>
    // Create a Three.js scene
    const scene = new THREE.Scene();

    // Create a camera
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 200);
    camera.lookAt(scene.position);

    // Create a renderer
    const renderer = new THREE.WebGLRenderer({ alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Create a parent object
    const parent = new THREE.Object3D();

    // Create a cube geometry
    const cubeSize = 150;
    const cubeGeometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
    const cubeMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.06 });
    const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
    parent.add(cube);

    // Create a base map plane
    const planeSize = 150;
    const planeGeometry = new THREE.PlaneGeometry(planeSize, planeSize);
    const planeMaterial = new THREE.MeshBasicMaterial({ color: 0xeeeeee });
    const plane = new THREE.Mesh(planeGeometry, planeMaterial);
    plane.rotation.x = -Math.PI / 2; // Rotate the plane to make it flat
    plane.position.set(0, -cubeSize / 2, 0); // Position the plane below the cube
    parent.add(plane);

    // Create x-axis
    const xAxisGeometry = new THREE.BufferGeometry();
    const xAxisMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 });
    const xAxisPoints = [];
    xAxisPoints.push(new THREE.Vector3(-cubeSize / 2, 0, 0));
    xAxisPoints.push(new THREE.Vector3(cubeSize / 2, 0, 0));
    xAxisGeometry.setFromPoints(xAxisPoints);
    const xAxis = new THREE.Line(xAxisGeometry, xAxisMaterial);
    parent.add(xAxis);

    // Create y-axis
    const yAxisGeometry = new THREE.BufferGeometry();
    const yAxisMaterial = new THREE.LineBasicMaterial({ color: 0x0000ff });
    const yAxisPoints = [];
    yAxisPoints.push(new THREE.Vector3(0, -cubeSize / 2, 0));
    yAxisPoints.push(new THREE.Vector3(0, cubeSize / 2, 0));
    yAxisGeometry.setFromPoints(yAxisPoints);
    const yAxis = new THREE.Line(yAxisGeometry, yAxisMaterial);
    parent.add(yAxis);

    // Create z-axis
    const zAxisGeometry = new THREE.BufferGeometry();
    const zAxisMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 });
    const zAxisPoints = [];
    zAxisPoints.push(new THREE.Vector3(0, 0, -cubeSize / 2));
    zAxisPoints.push(new THREE.Vector3(0, 0, cubeSize / 2));
    zAxisGeometry.setFromPoints(zAxisPoints);
    const zAxis = new THREE.Line(zAxisGeometry, zAxisMaterial);
    parent.add(zAxis);

    // Define the data for distance and time
    const data = [
      { distance: 10, time: 20 },
      { distance: 20, time: 40 },
      { distance: 30, time: 60 },
      { distance: 40, time: 70 },
      { distance: 50, time: 90 },
      { distance: 60, time: 110 }
    ];

    // Create lines based on the data
    for (let i = 0; i < data.length; i++) {
      const { distance, time } = data[i];

      const lineGeometry = new THREE.BufferGeometry();
      const lineMaterial = new THREE.LineBasicMaterial({ linewidth: 5 });
      let lineColor;

      // Set line color based on time
      if (time <= 30) {
        lineColor = new THREE.Color(0x00ff00); // Green
      } else if (time <= 45) {
        lineColor = new THREE.Color(0xffff00); // Yellow
      } else {
        lineColor = new THREE.Color(0xff0000); // Red
      }

      lineMaterial.color = lineColor;

      const linePoints = [];
      const x = distance / 60 * cubeSize - cubeSize / 2; // Normalize distance to fit cube size
      const y = time / 120 * cubeSize - cubeSize / 2; // Normalize time to fit cube size

      linePoints.push(new THREE.Vector3(x, y, 0)); // Start point at the base of the cube
      linePoints.push(new THREE.Vector3(x, y, cubeSize)); // End point at the top of the cube

      lineGeometry.setFromPoints(linePoints);

      const line = new THREE.Line(lineGeometry, lineMaterial);
      parent.add(line);
    }

    // Set initial cube rotation
    parent.rotation.y = Math.PI / 4;
    scene.add(parent);

    // Manual rotation function
    function rotateParent() {
      parent.rotation.y += 0.01;
      renderer.render(scene, camera);
    }

    // Call rotateParent function manually when the user moves the screen
    document.addEventListener('mousemove', function(event) {
      rotateParent();
    });

    // Render the scene
    renderer.render(scene, camera);
  </script>
</body>
</html>
