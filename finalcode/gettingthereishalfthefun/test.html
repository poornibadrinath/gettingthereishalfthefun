<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Space-Time Cube with OSM Base Map</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
  <script type="module">
    import * as THREE from 'https://cdn.skypack.dev/three@0.132.2/build/three.module.js';
    import { OrbitControls } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/controls/OrbitControls.js';

    // Create a Three.js scene
    const scene = new THREE.Scene();

    // Create a camera
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 200);
    camera.lookAt(scene.position);

    // Create a renderer
    const renderer = new THREE.WebGLRenderer({ alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Load Mapbox tile texture
    const textureLoader = new THREE.TextureLoader();
    const texture = textureLoader.load('https://api.mapbox.com/styles/v1/mapbox/streets-v11/static/77.6203,12.9561,12,0,0/1024x1024?access_token=pk.eyJ1IjoicG9vcm5pLWJhZHJpbmF0aCIsImEiOiJjanUwbmYzc3UwdDI3NGRtZ3kzMTltbWZpIn0.SB9PEksVcEwWvZJ9A7J9uA');

    // Create a parent object
    const parent = new THREE.Object3D();

    // Create a cube geometry
    const cubeSize = 600;
    const cubeGeometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
    const cubeMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.08 });
    const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
    parent.add(cube);

    // Create a base map plane
    const planeSize = 600;
    const planeGeometry = new THREE.PlaneGeometry(planeSize, planeSize);
    const planeMaterial = new THREE.MeshBasicMaterial({ map: texture });
    const plane = new THREE.Mesh(planeGeometry, planeMaterial);
    plane.rotation.x = -Math.PI / 2; // Rotate the plane to make it flat
    plane.position.set(0, -cubeSize / 2, 0); // Position the plane below the cube
    parent.add(plane);

    // Load the GeoJSON data
    const loader = new THREE.FileLoader();
    loader.load(
      'routeone.geojson',
      function (data) {
        const routeData = JSON.parse(data);
        const coordinates = routeData.features[0].geometry.coordinates;

        // Create a curve for the route
        const routePoints = [];
        for (let i = 0; i < coordinates.length; i++) {
          const [lng, lat] = coordinates[i];
          const x = (lng - 77.6203) * cubeSize / 0.1; // Adjust the scaling based on your data
          const y = (lat - 12.9561) * cubeSize / 0.1; // Adjust the scaling based on your data
          const z = i * cubeSize / (coordinates.length - 1); // Gradually increase z from 0 to cubeSize
          routePoints.push(new THREE.Vector3(x, y, z));
        }
        const routeCurve = new THREE.CatmullRomCurve3(routePoints);

        // Create a tube geometry for the route
        const routeTubeGeometry = new THREE.TubeGeometry(routeCurve, coordinates.length, 1, 8, false);
        const routeMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const routeTube = new THREE.Mesh(routeTubeGeometry, routeMaterial);
        cube.add(routeTube);

        // Function to handle route click event
        function handleRouteClick(event) {
          const rect = renderer.domElement.getBoundingClientRect();
          const canvasX = event.clientX - rect.left;
          const canvasY = event.clientY - rect.top;

          const mouse = new THREE.Vector2();
          mouse.x = (canvasX / renderer.domElement.clientWidth) * 2 - 1;
          mouse.y = -(canvasY / renderer.domElement.clientHeight) * 2 + 1;

          const raycaster = new THREE.Raycaster();
          raycaster.setFromCamera(mouse, camera);
          const intersects = raycaster.intersectObject(routeTube);

          if (intersects.length > 0) {
            const intersection = intersects[0];
            const position = intersection.point;

            // Get latitude and longitude from the clicked point
            const latitude = position.y;
            const longitude = position.x;

            // Get the percentage of the clicked point along the route
            const percent = routeCurve.getUtoTmapping(intersection.u).y;

            // Calculate the time based on the percentage
            const totalTime = 120; // Total time in minutes (2 hours)
            const time = percent * totalTime;

            // Display the latitude, longitude, and time in the popup
            popup.textContent = `Latitude: ${latitude.toFixed(6)}, Longitude: ${longitude.toFixed(6)}, Time: ${time.toFixed(2)} minutes`;
            popup.style.left = `${event.clientX}px`;
            popup.style.top = `${event.clientY}px`;
            popup.style.display = 'block';

            setTimeout(() => {
              popup.style.display = 'none';
            }, 6000);
          }
        }

        // Add event listener to handle route click
        renderer.domElement.addEventListener('click', handleRouteClick);
      },
      undefined,
      function (error) {
        console.error('Error loading GeoJSON file:', error);
      }
    );

    // Set initial cube rotation
    parent.rotation.y = Math.PI / 4;
    scene.add(parent);

    // Create orbit controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.update();

    // Add y-axis labels
    const fontLoader = new THREE.FontLoader();
    fontLoader.load('https://cdn.jsdelivr.net/npm/three/examples/fonts/helvetiker_regular.typeface.json', function (font) {
      const labelColor = 0x0000ff;
      const labelSize = 8;
      const labelHeight = 0.5;
      const labelDistance = 10;

      const labelContainer = new THREE.Object3D(); // Create a parent object for labels

      for (let i = 0; i <= 120; i += 10) {
        const labelText = `${i} mins`;
        const labelGeometry = new THREE.TextGeometry(labelText, {
          font: font,
          size: labelSize,
          height: labelHeight,
        });
        const labelMaterial = new THREE.MeshBasicMaterial({ color: labelColor });
        const label = new THREE.Mesh(labelGeometry, labelMaterial);
        label.position.set(-cubeSize / 2 - labelDistance, (cubeSize / 120) * i - cubeSize / 2, 0);
        labelContainer.add(label);
      }

      parent.add(labelContainer); // Add the label container to the parent object
    });

    // Create a popup for displaying route information
    const popup = document.createElement('div');
    popup.style.position = 'absolute';
    popup.style.background = 'white';
    popup.style.padding = '10px';
    popup.style.display = 'none';
    document.body.appendChild(popup);

    // Render the scene
    function render() {
      requestAnimationFrame(render);
      controls.update();
      renderer.render(scene, camera);
    }
    render();
  </script>
</body>
</html>
